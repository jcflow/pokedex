# AI Commands Log

This file tracks all prompts, AI suggestions, and critical thinking for this project.

| Phase | Prompt Goal | Prompt | AI Suggestion | Critical Thinking |
|-------|-------------|--------|---------------|-------------------|
| Project Setup | Establish project constraints and architecture | Act as a Senior Full Stack Engineer and Technical Lead for this session. We are building a technical interview project, and I need you to strictly follow these requirements to ensure the code passes a rigorous code review: Documentation & Logging (Critical): Before doing anything else, create a file named docs/ai-commands-log.md. Every time I give you a prompt, you must append a row to this file with the columns: Phase, Prompt Goal, Prompt, AI Suggestion, and Critical Thinking (explaining why you chose a specific pattern). Project Structure: Use a monorepo-style structure with pnpm as the package manager. Create scripts to run both client and server simultaneously with hot reload.Backend (./server): Use Ruby on Rails (Latest) in API-only mode with SQLite.- Use RSpec for unit tests and Selenium for integration tests.- Enforce strict style using RuboCop.- Implement RESTful endpoints (/pokemons, /login) and session-based authentication using HTTP-only Cookies.- Do not store Pokemon data in the DB; fetch from PokeAPI.co (cache if needed), but store User credentials in SQLite. Frontend (./client): Use Next.js (App Router) with TypeScript and TailwindCSS. Prioritize Server Side Rendering (SSR) for SEO on the Main and Detail views. Use Jest and React Testing Library for testing. State Management: Use Zustand for client UI state and TanStack Query for server state/caching. Ensure strict Accessibility (ARIA) and responsiveness matching the provided Figma design. Im plement pagination using numbered pages (no infinite scroll). Code Quality: All functions and classes must be documented (YARD for Ruby, JSDoc for TypeScript). Add inline comments for any complex logic explaining the "why". Immediate Action: Acknowledge these constraints, create the ai-commands-log file, then provide the exact terminal commands to initialize the project structure, and update CLAUDE.md file with the previous information. | Use monorepo with pnpm, Rails API backend, Next.js frontend, comprehensive testing, strict code quality. Monorepo with pnpm workspaces, Rails 7.x API-only + RSpec/Selenium/RuboCop, React 19 + Next.js 14+ App Router + SSR + TypeScript + TailwindCSS + Jest, Zustand for UI state, TanStack Query for server state, HTTP-only cookies for auth | **Why this architecture:** (1) **Monorepo + pnpm**: Better dependency deduplication and workspace management vs npm/yarn, single-command dev experience. (2) **Rails API-only**: Lightweight, RESTful conventions, excellent for session-based auth with Rack middleware. (3) **Next.js App Router + SSR**: Direct requirement for SEO, React Server Components reduce client JS bundle. (4) **Zustand**: Minimal boilerplate vs Redux, perfect for simple UI state (modals, filters). (5) **TanStack Query**: Industry standard for server state, built-in caching/pagination/optimistic updates. (6) **HTTP-only cookies**: Prevents XSS attacks on auth tokens, more secure than localStorage. (7) **RSpec + Selenium**: Rails testing standards, Selenium for E2E. (8) **YARD + JSDoc**: Standard documentation tools, critical for code review evaluation. |
| Planning | Generate comprehensive TDD development plan with user stories | Generate a comprehensive step-by-step development plan for this project, strictly following a Test-Driven Development (TDD) approach. For each step, you must provide: 1. The User Story (As a [role], I want [feature], so that [benefit]). 2. Detailed Acceptance Criteria (AC). These must be granular and testable, covering happy paths, edge cases (e.g., API failures, wrong credentials), and accessibility (ARIA) requirements. Output Requirement: Write this content directly into a file named docs/user-stories.md using the following Markdown structure: * Heading 2: [Step Number] - [User Story Name] * Normal Text: The User Story description. * Heading 3: Acceptance Criteria (Bulleted list). Ensure the 10 steps cover the full lifecycle: Project Setup -> Backend Auth (Session/Cookies) -> Backend Pokemon Proxy -> Frontend Login (SSR) -> Frontend Main Dashboard (SSR) -> Frontend Main Dashboard (Pagination/Search) -> Frontend Detail View (SSR) -> Final UI Polish & Accessibility Check. | Created comprehensive 10-step TDD roadmap in docs/user-stories.md: Step 1 (Database & User Model), Step 2 (Backend Auth API with Sessions), Step 3 (Pokemon Proxy Service), Step 4 (Frontend Login SSR), Step 5 (Main Dashboard SSR), Step 6 (Pagination & Search), Step 7 (Detail View SSR), Step 8 (UI Polish & A11y Audit), Step 9 (Backend Search/Sort), Step 10 (E2E Testing & Integration). Each step includes user story in standard format, 15-30 granular acceptance criteria covering happy paths/edge cases/accessibility, TDD workflow notes (Red-Green-Refactor), and copy-paste ready Claude prompts with exact commands. | **Reasoning:** Started with backend (Steps 1-3) to establish API contracts before building UI - this lets us validate the data layer works independently. Split features logically: Step 6 handles client-side filtering/pagination for responsiveness, Step 9 adds server-side search for cross-page queries. Put accessibility audit as Step 8 because it's easier to fix issues before E2E tests lock in the UI patterns. Each step has detailed acceptance criteria including edge cases (network failures, SQL injection, session timeouts) since interview panels specifically look for that. Added ready-to-use prompts with exact commands (bundle exec rspec, pnpm test) to eliminate back-and-forth. Required YARD/JSDoc throughout because clean documentation matters in code reviews. Note: Had to manually add technical implementation details (TDD workflow, recommended prompts) that weren't in original requirements but are essential for actually building this incrementally. |
| Validation | Verify monorepo setup and fix integration issues | Could you scan the package.json files for the Root, Client, and Server? I want to make sure everything is actually wired up correctly. Concurrency: Double-check that pnpm dev in the root effectively launches both Rails and Next.js at the same time without crashing. Consistency: Do we have standard commands like lint and test working from the root down to the workspaces? If not, let's fix them so I can run everything from the top level. Fixes: If you see any weirdness or missing standard scripts, just give me the JSON updates to fix them. | Scanned all package.json files and identified critical issues: (1) Root package.json had incomplete script coverage. (2) Client package.json had test script with --watch flag that would block CI - split into test (non-watch), test:watch, and test:ci (with coverage). (3) Server package.json lacked rbenv initialization - Rails server was using system Ruby 2.6 instead of rbenv Ruby 3.3.6, causing Bundler errors. (4) Server Gemfile had invalid platform syntax `platforms: %i[ windows jruby ]` incompatible with older Bundler - changed to `%i[ mingw mswin x64_mingw jruby ]`. (5) Next.js config used deprecated `images.domains` - migrated to `images.remotePatterns` format. Tested pnpm dev successfully - both Rails (port 3001) and Next.js (port 3000) start concurrently without crashes. | This validation caught several subtle issues I wouldn't have noticed without actually running the commands. The biggest problem was Rails trying to use the system Ruby instead of rbenv's version, turns out pnpm doesn't inherit the shell environment, so I had to explicitly initialize rbenv in each server script.
| Step 1: Database Schema and User Model | Implement database schema and User model following TDD | Implement **Step 1: Database Schema and User Model** using strict TDD.  1. **Test First (Red):** Create `spec/models/user_spec.rb` with failing tests for:    * `username`: Presence, case-insensitive uniqueness.    * `password`: Minimum 8 chars, `has_secure_password` integration.    * Edge cases: Duplicates, empty values.  2. **Implement (Green):**    * Generate the `User` model (`username:uniq`, `password_digest`).    * Apply migrations and add model validations to pass the specs.  3. **Refactor & Seed:**    * Add YARD documentation to the User model.    * Create an **idempotent** `db/seeds.rb` for the `admin/admin` user.    * Verify with `rspec` (must be green) and `rubocop`. | **Implementation:** (1) Created comprehensive spec/models/user_spec.rb with 19 tests covering: username presence/uniqueness (case-insensitive), password length (min 5 chars), has_secure_password authentication, edge cases (empty strings, whitespace, SQL injection, unicode, special chars), and database-level uniqueness constraint enforcement. (2) Ran specs first - failed with "uninitialized constant User" (RED phase - confirmed TDD). (3) Generated User model with `rails g model User username:string:uniq password_digest:string` - created migration with unique index on username and base model class. (4) Ran migration successfully - created users table with username/password_digest columns and unique index. (5) Implemented validations in app/models/user.rb: added has_secure_password, validates presence/uniqueness of username (case_sensitive: false), validates password length (minimum: 5, allow_nil: true to work with has_secure_password). (6) Added comprehensive YARD documentation explaining authentication flow with bcrypt. (7) Created idempotent seed data using find_or_initialize_by pattern for admin user (username: 'admin', password: 'admin'). (8) All 19 RSpec tests passed (GREEN phase). (9) RuboCop reported 0 offenses (REFACTOR phase - code quality confirmed). | Wrote 19 tests first covering edge cases (SQL injection, unicode, etc.). Password min was initially 8 chars but had to change to 5 since 'admin' is hardcoded. Rails generator overwrote the test file which was annoying. Used `case_sensitive: false` for username since SQLite DB index is case-sensitive by default. Added `allow_nil: true` on password validation so has_secure_password allows updates without re-entering password. Used `find_or_initialize_by` for idempotent seeds with better output. Database constraint test bypasses validations to confirm unique index works (defense in depth). Red-Green-Refactor worked well - minimal code to pass tests.
| Step 2: Backend Authentication API | Implement login/logout endpoints with session cookies following TDD | Implement **Step 2: Backend Authentication API** with session-based auth using strict TDD. 1. **Test First (Red):** Create `spec/requests/api/sessions_spec.rb` with 25 tests covering: POST /api/login (valid/invalid/missing credentials, case-insensitive username), POST /api/logout (with/without session), GET /api/session (authenticated/unauthenticated), security (password_digest never exposed). 2. **Implement (Green):** Generate SessionsController, add routes, implement create/destroy/show actions with proper error handling. 3. **Configure:** Enable sessions/cookies in API-only app (middleware + ApplicationController include), configure CORS for localhost:3000 with credentials:true, configure cookie_store session. 4. **Refactor:** Add YARD docs, verify rspec and rubocop. | **Implementation:** (1) Created spec/requests/api/sessions_spec.rb with 25 comprehensive tests covering all authentication flows, edge cases, and security requirements. Tests initially failed with 404s (RED phase). (2) Generated Api::SessionsController with rails g controller, added routes (POST /api/login, POST /api/logout, GET /api/session). (3) Implemented controller actions: create (validates params, case-insensitive username lookup via LOWER(), authenticates with bcrypt, sets session[:user_id]), destroy (clears session), show (checks current_user). Added private helper user_json to exclude password_digest from responses. (4) Configured CORS in config/initializers/cors.rb: allowed localhost:3000 origin with credentials:true for session cookies. (5) Enabled sessions in API-only mode: added ActionDispatch::Cookies and ActionDispatch::Session::CookieStore middleware in application.rb, included ActionController::Cookies in ApplicationController. (6) Created config/initializers/session_store.rb with cookie_store config (key: _pokedex_session, same_site: lax, secure: false for development). (7) Fixed test issue: changed let(:user) to let!(:user) to ensure user created before tests run. Fixed session cookie test to check session[:user_id] instead of response.cookies. (8) All 25 tests passed (GREEN phase). (9) RuboCop auto-corrected 15 string literal violations, 0 offenses after corrections (REFACTOR phase). | Rails generator overwrote the test file again, so had to restore it manually. API-only mode disables sessions by default which caught me off guard. Had to add the cookie middleware and include the Cookies concern in ApplicationController. Used LOWER() SQL function for case-insensitive username lookup since SQLite doesn't have a built-in way to do this. The user_json helper is critical for security to prevent password_digest from leaking in responses. Session cookie testing in request specs doesn't work like I expected, couldn't access response.cookies so had to check session[:user_id] directly instead. CORS credentials:true is mandatory for cookies to work cross-origin. Fixed a bug where tests were failing because let is lazy-evaluated, changed to let! to force user creation upfront.
| Step 3: Backend Pokemon Proxy Service | Implement Pokemon data proxy with caching following TDD | Implement **Step 3: Backend Pokemon Proxy Service** using strict TDD. 1. **Read PokeAPI docs:** Understand response format for list (/pokemon) and detail (/pokemon/:id) endpoints. 2. **Setup:** Add WebMock gem to Gemfile test group, bundle install. 3. **Test First (Red):** Create tests covering: fetch_list (success, pagination, caching), fetch_detail (success, abilities/moves/forms/sprites/types, caching), error handling (timeout, 404, 500, network errors). Create tests covering: GET /api/pokemons (authenticated, not authenticated, PokeAPI failure), GET /api/pokemons/:id (authenticated, not authenticated, 404, PokeAPI failure). 4. **Implement (Green):** Create app/services/pokemon_service.rb with fetch_list/fetch_detail methods using HTTParty and Rails.cache. Create app/controllers/api/pokemons_controller.rb with index/show actions and authentication. Add routes for pokemons API. 5. **Refactor:** Add YARD docs, run rspec, run rubocop. | **Implementation:** (1) Fetched PokeAPI documentation - learned list endpoint returns count/next/previous/results with pagination via offset/limit params, detail endpoint returns comprehensive Pokemon data including abilities/moves/forms/sprites/types. (2) Added WebMock gem to Gemfile test group, ran bundle install successfully after configuring rbenv to use Ruby 3.3.6. (3) Added require 'webmock/rspec' to spec/rails_helper.rb. Changed config.cache_store from :null_store to :memory_store in test environment to enable caching tests. (4) Created spec/services/pokemon_service_spec.rb with 22 comprehensive tests: fetch_list tests (3 success scenarios for pagination/default params, 2 caching tests for same/different pages, 4 error tests for timeout/404/500/network), fetch_detail tests (7 success tests for all data fields, 2 caching tests, 4 error tests). Used WebMock to stub all PokeAPI requests. (5) Ran service spec - failed with "uninitialized constant PokemonService" (RED phase - confirmed TDD). (6) Created app/services/pokemon_service.rb: included HTTParty with base_uri, defined custom error classes (ServiceError, NotFoundError), implemented fetch_list method (calculates offset from page, uses Rails.cache.fetch with 1 hour expiration), implemented fetch_detail method (accepts id or name, uses caching), added private fetch_with_error_handling method to handle timeouts/404s/500s/network errors. Added comprehensive YARD documentation. (7) Ran service spec again - all 22 tests passed (GREEN phase). (8) Created spec/requests/api/pokemons_spec.rb with 23 tests: GET /api/pokemons tests (5 authenticated scenarios for pagination/params, 2 unauthenticated, 2 PokeAPI failure), GET /api/pokemons/:id tests (8 authenticated scenarios including all data fields and name lookup, 2 unauthenticated, 2 not found, 2 PokeAPI failure). (9) Ran request spec - failed with 404s since controller/routes didn't exist (RED phase). (10) Added resources :pokemons to routes.rb in api namespace. (11) Created app/controllers/api/pokemons_controller.rb: added before_action :require_authentication, implemented index action (extracts page/limit params with defaults, calls pokemon_service.fetch_list, handles ServiceError with 503 status), implemented show action (calls pokemon_service.fetch_detail, handles NotFoundError with 404, ServiceError with 503), added private methods (current_user, require_authentication returning 401 if not authenticated, pokemon_service instance). Added comprehensive YARD documentation. (12) Ran request spec - all 23 tests passed (GREEN phase). (13) Ran all specs - 89 examples, 0 failures including previous auth tests (integration confirmed). (14) Ran RuboCop - 4 string literal violations in pokemon_service.rb (single quotes instead of double). Auto-corrected with rubocop -A. (15) Re-ran RuboCop - 0 offenses (REFACTOR phase complete). (16) Final spec run - 89 examples, 0 failures confirmed. | HTTParty was the obvious choice here over Net::HTTP for cleaner base_uri setup and automatic JSON parsing. Split error handling into ServiceError (base) and NotFoundError (subclass) so the controller can map them properly to HTTP status codes. Rails.cache.fetch with scoped keys prevents cache collisions across different pages. The test environment was using :null_store by default which broke the caching specs, switching to :memory_store fixed that. WebMock is essential for testing external APIs without making real HTTP calls. Kept authentication consistent with SessionsController pattern using the same current_user helper and before_action filter. Controller translates service exceptions to appropriate responses: 404 for not found, 503 for upstream failures, 401 for auth. Skipped the Rails generator this time to avoid overwriting test files. RuboCop flagged quote style issues which auto-corrected cleanly. The 89 passing tests confirm no regressions from auth work.
