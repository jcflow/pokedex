# AI Commands Log

This file tracks all prompts, AI suggestions, and critical thinking for this project.

| Phase | Prompt Goal | Prompt | AI Suggestion | Critical Thinking |
|-------|-------------|--------|---------------|-------------------|
| Project Setup | Establish project constraints and architecture | Act as a Senior Full Stack Engineer and Technical Lead for this session. We are building a technical interview project, and I need you to strictly follow these requirements to ensure the code passes a rigorous code review: Documentation & Logging (Critical): Before doing anything else, create a file named docs/ai-commands-log.md. Every time I give you a prompt, you must append a row to this file with the columns: Phase, Prompt Goal, Prompt, AI Suggestion, and Critical Thinking (explaining why you chose a specific pattern). Project Structure: Use a monorepo-style structure with pnpm as the package manager. Create scripts to run both client and server simultaneously with hot reload.Backend (./server): Use Ruby on Rails (Latest) in API-only mode with SQLite.- Use RSpec for unit tests and Selenium for integration tests.- Enforce strict style using RuboCop.- Implement RESTful endpoints (/pokemons, /login) and session-based authentication using HTTP-only Cookies.- Do not store Pokemon data in the DB; fetch from PokeAPI.co (cache if needed), but store User credentials in SQLite. Frontend (./client): Use Next.js (App Router) with TypeScript and TailwindCSS. Prioritize Server Side Rendering (SSR) for SEO on the Main and Detail views. Use Jest and React Testing Library for testing. State Management: Use Zustand for client UI state and TanStack Query for server state/caching. Ensure strict Accessibility (ARIA) and responsiveness matching the provided Figma design. Im plement pagination using numbered pages (no infinite scroll). Code Quality: All functions and classes must be documented (YARD for Ruby, JSDoc for TypeScript). Add inline comments for any complex logic explaining the "why". Immediate Action: Acknowledge these constraints, create the ai-commands-log file, then provide the exact terminal commands to initialize the project structure, and update CLAUDE.md file with the previous information. | Use monorepo with pnpm, Rails API backend, Next.js frontend, comprehensive testing, strict code quality. Monorepo with pnpm workspaces, Rails 7.x API-only + RSpec/Selenium/RuboCop, React 19 + Next.js 14+ App Router + SSR + TypeScript + TailwindCSS + Jest, Zustand for UI state, TanStack Query for server state, HTTP-only cookies for auth | **Why this architecture:** (1) **Monorepo + pnpm**: Better dependency deduplication and workspace management vs npm/yarn, single-command dev experience. (2) **Rails API-only**: Lightweight, RESTful conventions, excellent for session-based auth with Rack middleware. (3) **Next.js App Router + SSR**: Direct requirement for SEO, React Server Components reduce client JS bundle. (4) **Zustand**: Minimal boilerplate vs Redux, perfect for simple UI state (modals, filters). (5) **TanStack Query**: Industry standard for server state, built-in caching/pagination/optimistic updates. (6) **HTTP-only cookies**: Prevents XSS attacks on auth tokens, more secure than localStorage. (7) **RSpec + Selenium**: Rails testing standards, Selenium for E2E. (8) **YARD + JSDoc**: Standard documentation tools, critical for code review evaluation. |
| Planning | Generate comprehensive TDD development plan with user stories | Generate a comprehensive step-by-step development plan for this project, strictly following a Test-Driven Development (TDD) approach. For each step, you must provide: 1. The User Story (As a [role], I want [feature], so that [benefit]). 2. Detailed Acceptance Criteria (AC). These must be granular and testable, covering happy paths, edge cases (e.g., API failures, wrong credentials), and accessibility (ARIA) requirements. Output Requirement: Write this content directly into a file named docs/user-stories.md using the following Markdown structure: * Heading 2: [Step Number] - [User Story Name] * Normal Text: The User Story description. * Heading 3: Acceptance Criteria (Bulleted list). Ensure the 10 steps cover the full lifecycle: Project Setup -> Backend Auth (Session/Cookies) -> Backend Pokemon Proxy -> Frontend Login (SSR) -> Frontend Main Dashboard (SSR) -> Frontend Main Dashboard (Pagination/Search) -> Frontend Detail View (SSR) -> Final UI Polish & Accessibility Check. | Created comprehensive 10-step TDD roadmap in docs/user-stories.md: Step 1 (Database & User Model), Step 2 (Backend Auth API with Sessions), Step 3 (Pokemon Proxy Service), Step 4 (Frontend Login SSR), Step 5 (Main Dashboard SSR), Step 6 (Pagination & Search), Step 7 (Detail View SSR), Step 8 (UI Polish & A11y Audit), Step 9 (Backend Search/Sort), Step 10 (E2E Testing & Integration). Each step includes user story in standard format, 15-30 granular acceptance criteria covering happy paths/edge cases/accessibility, TDD workflow notes (Red-Green-Refactor), and copy-paste ready Claude prompts with exact commands. | **Reasoning:** Started with backend (Steps 1-3) to establish API contracts before building UI - this lets us validate the data layer works independently. Split features logically: Step 6 handles client-side filtering/pagination for responsiveness, Step 9 adds server-side search for cross-page queries. Put accessibility audit as Step 8 because it's easier to fix issues before E2E tests lock in the UI patterns. Each step has detailed acceptance criteria including edge cases (network failures, SQL injection, session timeouts) since interview panels specifically look for that. Added ready-to-use prompts with exact commands (bundle exec rspec, pnpm test) to eliminate back-and-forth. Required YARD/JSDoc throughout because clean documentation matters in code reviews. Note: Had to manually add technical implementation details (TDD workflow, recommended prompts) that weren't in original requirements but are essential for actually building this incrementally. |
